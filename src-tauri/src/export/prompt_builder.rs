use crate::db::{Database, File};
use crate::error::Result;
use crate::export::ExportConfig;
use chrono::Utc;
use std::path::Path;

/// Builds STARTER_PROMPT.md and feature-specific prompts
pub struct PromptBuilder {
    db: Database,
}

impl PromptBuilder {
    pub fn new(db: Database) -> Self {
        Self { db }
    }

    /// Build the STARTER_PROMPT.md content
    pub async fn build_starter_prompt(&self, config: &ExportConfig) -> Result<String> {
        let conn = self.db.get_connection();
        let files = crate::db::operations::list_files(conn, 10000, 0)?;

        let project_name = config.project_name.clone()
            .unwrap_or_else(|| self.detect_project_name(&files));

        let project_type = self.detect_project_type(&files);
        let frameworks = self.detect_frameworks(&files);
        let now = Utc::now().format("%Y-%m-%d %H:%M:%S UTC");

        let mut prompt = String::new();

        // Header
        prompt.push_str(&format!(
            "# {} IMPLEMENTATION - VS CODE CLAUDE STARTER\n\n\
             **Generated by Cortex on {}**\n\n\
             ---\n\n",
            project_name.to_uppercase(),
            now
        ));

        // Context section
        prompt.push_str("## Context\n\n");
        prompt.push_str(&format!(
            "I'm working on **{}**, a {}",
            project_name,
            project_type
        ));

        if !frameworks.is_empty() {
            prompt.push_str(&format!(" built with {}", frameworks.join(", ")));
        }

        prompt.push_str(".\n\n");

        // Technology Stack
        prompt.push_str("### Technology Stack\n\n");
        prompt.push_str(&self.build_tech_stack(&files)?);
        prompt.push_str("\n");

        // Architecture
        prompt.push_str("### Architecture\n\n");
        prompt.push_str(&self.build_architecture_description(&files)?);
        prompt.push_str("\n");

        // Your Role
        prompt.push_str("## Your Role\n\n");
        prompt.push_str(
            "You are my implementation partner. **Cortex has indexed this project and provided \
             you with comprehensive context** via the `CONTEXT.md` file. Your job is to help me \
             implement features, fix bugs, refactor code, and improve the codebase.\n\n\
             **Key Principles:**\n\n\
             - Always read the CONTEXT.md file first to understand the full project structure\n\
             - Ask clarifying questions when requirements are unclear\n\
             - Follow existing code patterns and conventions\n\
             - Write clean, maintainable, well-documented code\n\
             - Include tests for new functionality\n\n"
        );

        // Critical Requirements
        prompt.push_str("## Critical Requirements\n\n");
        prompt.push_str(&self.build_requirements(&files)?);
        prompt.push_str("\n");

        // Project Structure
        prompt.push_str("## Project Structure\n\n");
        prompt.push_str("```\n");
        prompt.push_str(&self.build_simplified_tree(&files)?);
        prompt.push_str("```\n\n");

        // Quick Reference
        prompt.push_str("## Quick Reference\n\n");
        prompt.push_str(&self.build_quick_reference(&files)?);
        prompt.push_str("\n");

        // Current Focus
        if let Some(custom_context) = &config.custom_context {
            prompt.push_str("## Current Focus\n\n");
            prompt.push_str(custom_context);
            prompt.push_str("\n\n");
        } else {
            prompt.push_str("## Let's Begin!\n\n");
            prompt.push_str(
                "Ready to start implementation. What would you like to work on?\n\n\
                 **Common tasks:**\n\
                 - \"Let's implement [feature]\" → I'll create an implementation plan\n\
                 - \"Help me fix [bug]\" → I'll investigate and propose fixes\n\
                 - \"Review this code\" → I'll analyze and suggest improvements\n\
                 - \"Add tests for [module]\" → I'll create comprehensive tests\n\
                 - \"Refactor [component]\" → I'll improve code quality\n\n"
            );
        }

        // Footer
        prompt.push_str(
            "---\n\n\
             **Quick Commands:**\n\
             - \"Show me the architecture\" → I'll explain the project structure in detail\n\
             - \"What's in CONTEXT.md?\" → I'll summarize the key information\n\
             - \"How does [feature] work?\" → I'll explain the implementation\n\
             - \"Where is [functionality]?\" → I'll point you to the relevant files\n\n"
        );

        Ok(prompt)
    }

    /// Build ADD_FEATURE.md prompt template
    pub async fn build_feature_prompt(
        &self,
        feature_name: &str,
        feature_description: &str,
    ) -> Result<String> {
        let conn = self.db.get_connection();
        let files = crate::db::operations::list_files(conn, 10000, 0)?;

        let mut prompt = String::from(&format!(
            "# FEATURE IMPLEMENTATION: {}\n\n\
             **Generated by Cortex**\n\n\
             ---\n\n",
            feature_name
        ));

        prompt.push_str("## Feature Request\n\n");
        prompt.push_str(feature_description);
        prompt.push_str("\n\n");

        prompt.push_str("## Existing Context\n\n");
        prompt.push_str(
            "Based on the indexed codebase (see CONTEXT.md), here's what's relevant:\n\n"
        );

        prompt.push_str("### Project Architecture\n\n");
        prompt.push_str(&self.build_architecture_description(&files)?);
        prompt.push_str("\n");

        prompt.push_str("## Implementation Plan\n\n");
        prompt.push_str(
            "Please implement this feature following these steps:\n\n\
             1. **Understand**: Review the CONTEXT.md file and related files\n\
             2. **Plan**: Outline the changes needed (files to create/modify)\n\
             3. **Implement**: Create/modify files following project patterns\n\
             4. **Test**: Include test coverage for new functionality\n\
             5. **Document**: Update any affected documentation\n\n"
        );

        prompt.push_str("## Constraints\n\n");
        prompt.push_str(&self.build_requirements(&files)?);
        prompt.push_str("\n");

        prompt.push_str("## Expected Deliverables\n\n");
        prompt.push_str(
            "- [ ] Feature implementation (code)\n\
             - [ ] Unit tests\n\
             - [ ] Integration tests (if applicable)\n\
             - [ ] Documentation updates\n\
             - [ ] Type definitions (if applicable)\n\n\
             ---\n\n\
             **Begin implementation when ready. Ask clarifying questions if needed.**\n"
        );

        Ok(prompt)
    }

    /// Build FIX_BUG.md prompt template
    pub async fn build_bugfix_prompt(
        &self,
        bug_description: &str,
        steps_to_reproduce: &str,
    ) -> Result<String> {
        let conn = self.db.get_connection();
        let files = crate::db::operations::list_files(conn, 10000, 0)?;

        let mut prompt = String::from(
            "# BUG FIX IMPLEMENTATION\n\n\
             **Generated by Cortex**\n\n\
             ---\n\n"
        );

        prompt.push_str("## Bug Description\n\n");
        prompt.push_str(bug_description);
        prompt.push_str("\n\n");

        prompt.push_str("## Steps to Reproduce\n\n");
        prompt.push_str(steps_to_reproduce);
        prompt.push_str("\n\n");

        prompt.push_str("## Investigation Approach\n\n");
        prompt.push_str(
            "1. **Understand**: Review CONTEXT.md to understand the codebase\n\
             2. **Locate**: Identify the files/modules related to this bug\n\
             3. **Analyze**: Determine the root cause\n\
             4. **Fix**: Implement the fix following existing patterns\n\
             5. **Test**: Add regression tests to prevent recurrence\n\
             6. **Verify**: Ensure the fix doesn't break existing functionality\n\n"
        );

        prompt.push_str("## Project Context\n\n");
        prompt.push_str(&self.build_architecture_description(&files)?);
        prompt.push_str("\n");

        prompt.push_str("## Expected Deliverables\n\n");
        prompt.push_str(
            "- [ ] Root cause analysis\n\
             - [ ] Bug fix implementation\n\
             - [ ] Regression test\n\
             - [ ] Verification that existing tests still pass\n\n\
             ---\n\n\
             **Start by analyzing the bug and identifying the relevant code.**\n"
        );

        Ok(prompt)
    }

    /// Build REFACTOR.md prompt template
    pub async fn build_refactor_prompt(
        &self,
        target_module: &str,
        refactor_goals: &str,
    ) -> Result<String> {
        let mut prompt = String::from(
            "# CODE REFACTORING TASK\n\n\
             **Generated by Cortex**\n\n\
             ---\n\n"
        );

        prompt.push_str(&format!("## Target Module\n\n`{}`\n\n", target_module));
        prompt.push_str("## Refactoring Goals\n\n");
        prompt.push_str(refactor_goals);
        prompt.push_str("\n\n");

        prompt.push_str("## Refactoring Principles\n\n");
        prompt.push_str(
            "1. **Maintain Behavior**: Ensure existing functionality remains unchanged\n\
             2. **Improve Design**: Enhance code structure and readability\n\
             3. **Follow Patterns**: Use established patterns from the codebase\n\
             4. **Test Coverage**: Ensure tests pass before and after refactoring\n\
             5. **Document Changes**: Update comments and documentation\n\n"
        );

        prompt.push_str("## Approach\n\n");
        prompt.push_str(
            "1. Read CONTEXT.md to understand the current architecture\n\
             2. Review the target module and identify improvement opportunities\n\
             3. Create a refactoring plan (what will change)\n\
             4. Implement changes incrementally\n\
             5. Run tests after each change\n\
             6. Update documentation\n\n"
        );

        prompt.push_str("## Expected Deliverables\n\n");
        prompt.push_str(
            "- [ ] Refactoring plan (before starting)\n\
             - [ ] Refactored code\n\
             - [ ] All existing tests passing\n\
             - [ ] Documentation updates\n\
             - [ ] Summary of changes made\n\n\
             ---\n\n\
             **Start by reviewing the current code and creating a refactoring plan.**\n"
        );

        Ok(prompt)
    }

    // Helper methods

    fn detect_project_name(&self, files: &[File]) -> String {
        files.first()
            .and_then(|f| {
                Path::new(&f.root_path)
                    .file_name()
                    .and_then(|n| n.to_str())
                    .map(|s| s.to_string())
            })
            .unwrap_or_else(|| "Project".to_string())
    }

    fn detect_project_type(&self, files: &[File]) -> String {
        if files.iter().any(|f| f.filename == "Cargo.toml") {
            if files.iter().any(|f| f.filename == "package.json") {
                return "Rust + SvelteKit Desktop Application (Tauri)".to_string();
            }
            return "Rust Application".to_string();
        }

        if files.iter().any(|f| f.filename == "package.json") {
            return "JavaScript/TypeScript Application".to_string();
        }

        if files.iter().any(|f| f.filename == "requirements.txt") {
            return "Python Application".to_string();
        }

        "Software Project".to_string()
    }

    fn detect_frameworks(&self, files: &[File]) -> Vec<String> {
        let mut frameworks = Vec::new();

        if files.iter().any(|f| f.filename == "tauri.conf.json") {
            frameworks.push("Tauri 2.0".to_string());
        }

        if files.iter().any(|f| f.path.contains("svelte.config")) {
            frameworks.push("SvelteKit".to_string());
        }

        if files.iter().any(|f| f.path.contains("next.config")) {
            frameworks.push("Next.js".to_string());
        }

        frameworks
    }

    fn build_tech_stack(&self, files: &[File]) -> Result<String> {
        let mut stack = String::new();

        if files.iter().any(|f| f.filename == "Cargo.toml") {
            stack.push_str("- **Rust**: Systems programming language\n");
        }

        if files.iter().any(|f| f.filename == "package.json") {
            stack.push_str("- **TypeScript/JavaScript**: Frontend development\n");
        }

        if files.iter().any(|f| f.filename == "tauri.conf.json") {
            stack.push_str("- **Tauri**: Desktop application framework\n");
        }

        if files.iter().any(|f| f.path.contains("svelte")) {
            stack.push_str("- **SvelteKit**: UI framework\n");
        }

        if files.iter().any(|f| f.filename == "rusqlite" || f.path.contains("sqlite")) {
            stack.push_str("- **SQLite**: Local database\n");
        }

        Ok(stack)
    }

    fn build_architecture_description(&self, files: &[File]) -> Result<String> {
        let mut desc = String::new();

        if files.iter().any(|f| f.filename == "Cargo.toml" && f.filename == "package.json") {
            desc.push_str(
                "This is a **Tauri desktop application** with:\n\
                 - **Backend**: Rust (performance, system access, database)\n\
                 - **Frontend**: SvelteKit (reactive UI, routing)\n\
                 - **IPC**: Tauri commands for frontend-backend communication\n\
                 - **Database**: SQLite with FTS5 for full-text search\n\n"
            );
        } else if files.iter().any(|f| f.filename == "Cargo.toml") {
            desc.push_str("This is a **Rust application**.\n\n");
        } else if files.iter().any(|f| f.filename == "package.json") {
            desc.push_str("This is a **JavaScript/TypeScript application**.\n\n");
        }

        Ok(desc)
    }

    fn build_requirements(&self, files: &[File]) -> Result<String> {
        let mut requirements = String::new();

        if files.iter().any(|f| f.file_type == "rs") {
            requirements.push_str(
                "**Rust code must:**\n\
                 1. Follow Rust naming conventions (snake_case for functions/variables)\n\
                 2. Include proper error handling with Result types\n\
                 3. Use meaningful variable names\n\
                 4. Add doc comments for public functions\n\n"
            );
        }

        if files.iter().any(|f| f.file_type == "ts" || f.file_type == "svelte") {
            requirements.push_str(
                "**TypeScript/Svelte code must:**\n\
                 1. Follow TypeScript naming conventions (camelCase for functions/variables)\n\
                 2. Use proper type annotations\n\
                 3. Follow existing component patterns\n\
                 4. Handle errors gracefully\n\n"
            );
        }

        requirements.push_str(
            "**All code must:**\n\
             - Be clean, readable, and maintainable\n\
             - Follow existing patterns in the codebase\n\
             - Include appropriate error handling\n\
             - Be well-documented (comments for complex logic)\n"
        );

        Ok(requirements)
    }

    fn build_simplified_tree(&self, files: &[File]) -> Result<String> {
        let mut dirs: std::collections::HashSet<String> = std::collections::HashSet::new();

        for file in files.iter().take(100) {
            if let Some(parent) = Path::new(&file.path).parent() {
                if let Some(dir_str) = parent.to_str() {
                    // Get relative path from root
                    if let Some(root) = files.first() {
                        if let Ok(relative) = Path::new(dir_str).strip_prefix(&root.root_path) {
                            if let Some(rel_str) = relative.to_str() {
                                if !rel_str.is_empty() {
                                    dirs.insert(rel_str.to_string());
                                }
                            }
                        }
                    }
                }
            }
        }

        let mut sorted_dirs: Vec<_> = dirs.into_iter().collect();
        sorted_dirs.sort();

        if sorted_dirs.is_empty() {
            return Ok("./\n".to_string());
        }

        Ok(sorted_dirs.iter().take(20).map(|d| format!("./{}/", d)).collect::<Vec<_>>().join("\n"))
    }

    fn build_quick_reference(&self, files: &[File]) -> Result<String> {
        let mut reference = String::new();

        // Find key files
        let main_files: Vec<_> = files.iter()
            .filter(|f| {
                f.filename == "main.rs" ||
                f.filename == "lib.rs" ||
                f.filename == "main.ts" ||
                f.filename == "index.ts"
            })
            .collect();

        if !main_files.is_empty() {
            reference.push_str("**Entry Points:**\n");
            for file in main_files {
                reference.push_str(&format!("- `{}`\n", file.path));
            }
            reference.push_str("\n");
        }

        // Config files
        let config_files: Vec<_> = files.iter()
            .filter(|f| {
                f.filename == "Cargo.toml" ||
                f.filename == "package.json" ||
                f.filename == "tauri.conf.json"
            })
            .collect();

        if !config_files.is_empty() {
            reference.push_str("**Configuration:**\n");
            for file in config_files {
                reference.push_str(&format!("- `{}`\n", file.filename));
            }
            reference.push_str("\n");
        }

        Ok(reference)
    }
}
