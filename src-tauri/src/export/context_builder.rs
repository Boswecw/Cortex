use crate::db::{Database, File};
use crate::error::Result;
use crate::export::{ExportConfig, ExportStats};
use chrono::Utc;
use std::collections::HashMap;
use std::path::Path;

/// Builds comprehensive CONTEXT.md file for VS Code Claude
pub struct ContextBuilder {
    db: Database,
}

impl ContextBuilder {
    pub fn new(db: Database) -> Self {
        Self { db }
    }

    /// Build the complete CONTEXT.md content
    pub async fn build_context(&self, config: &ExportConfig) -> Result<(String, ExportStats)> {
        // Get files to export
        let files = self.get_files_for_export(config)?;

        // Build context sections
        let mut context = String::new();

        // 1. Header
        context.push_str(&self.build_header(config, &files)?);

        // 2. Project Overview
        context.push_str(&self.build_project_overview(&files)?);

        // 3. Architecture Summary
        context.push_str(&self.build_architecture_summary(&files)?);

        // 4. Project Structure
        context.push_str(&self.build_project_structure(&files)?);

        // 5. Key Files
        context.push_str(&self.build_key_files(&files)?);

        // 6. Dependencies
        context.push_str(&self.build_dependencies(&files)?);

        // 7. Code Patterns
        context.push_str(&self.build_code_patterns(&files)?);

        // 8. Current State
        context.push_str(&self.build_current_state(&files)?);

        // Calculate stats
        let stats = self.calculate_stats(&files)?;

        Ok((context, stats))
    }

    /// Get files to export based on configuration
    fn get_files_for_export(&self, _config: &ExportConfig) -> Result<Vec<File>> {
        let conn = self.db.get_connection();

        // For now, get all indexed files (collection support will be added in Phase 3)
        let files = crate::db::operations::list_files(conn, 10000, 0)?;

        Ok(files)
    }

    /// Build the markdown header
    fn build_header(&self, config: &ExportConfig, files: &[File]) -> Result<String> {
        let project_name = config.project_name.clone()
            .unwrap_or_else(|| self.detect_project_name(files));

        let now = Utc::now().format("%Y-%m-%d %H:%M:%S UTC");

        Ok(format!(
            "# PROJECT CONTEXT: {}\n\n\
             **Generated by Cortex on {}**\n\n\
             ---\n\n",
            project_name,
            now
        ))
    }

    /// Build project overview section
    fn build_project_overview(&self, files: &[File]) -> Result<String> {
        let mut overview = String::from("## Project Overview\n\n");

        // Detect project type
        let project_type = self.detect_project_type(files);
        overview.push_str(&format!("- **Type**: {}\n", project_type));

        // Detect frameworks
        let frameworks = self.detect_frameworks(files);
        if !frameworks.is_empty() {
            overview.push_str(&format!("- **Frameworks**: {}\n", frameworks.join(", ")));
        }

        // Entry points
        let entry_points = self.detect_entry_points(files);
        if !entry_points.is_empty() {
            overview.push_str("- **Entry Points**:\n");
            for entry_point in entry_points {
                overview.push_str(&format!("  - `{}`\n", entry_point));
            }
        }

        // File statistics
        let total_files = files.len();
        let total_size: i64 = files.iter().map(|f| f.size).sum();
        overview.push_str(&format!("- **Total Files**: {}\n", total_files));
        overview.push_str(&format!("- **Total Size**: {}\n", crate::export::format_file_size(total_size)));

        overview.push_str("\n");
        Ok(overview)
    }

    /// Build architecture summary section
    fn build_architecture_summary(&self, files: &[File]) -> Result<String> {
        let mut summary = String::from("## Architecture Summary\n\n");

        // Detect directory structure
        let structure = self.analyze_directory_structure(files);

        summary.push_str("**Directory Organization:**\n\n");
        summary.push_str("```\n");
        summary.push_str(&structure);
        summary.push_str("```\n\n");

        // Detect architecture pattern
        let pattern = self.detect_architecture_pattern(files);
        summary.push_str(&format!("**Architecture Pattern**: {}\n\n", pattern));

        summary.push_str("**Layer Separation:**\n\n");
        let layers = self.detect_layers(files);
        for (layer, count) in layers {
            summary.push_str(&format!("- **{}**: {} files\n", layer, count));
        }

        summary.push_str("\n");
        Ok(summary)
    }

    /// Build project structure (directory tree)
    fn build_project_structure(&self, files: &[File]) -> Result<String> {
        let mut structure = String::from("## Project Structure\n\n```\n");

        // Group files by directory
        let tree = self.build_directory_tree(files);

        structure.push_str(&tree);
        structure.push_str("```\n\n");

        Ok(structure)
    }

    /// Build key files section
    fn build_key_files(&self, files: &[File]) -> Result<String> {
        let mut key_files = String::from("## Key Files\n\n");

        let conn = self.db.get_connection();

        // Identify important files
        let important_files = self.identify_important_files(files);

        for file in important_files.iter().take(20) {
            // Get file content summary
            let content = crate::db::operations::get_file_content(conn, file.id)?;
            let summary = content
                .and_then(|c| c.summary)
                .unwrap_or_else(|| "No summary available".to_string());

            key_files.push_str(&format!("### `{}`\n\n", file.path));
            key_files.push_str(&format!("**Type**: {} | **Size**: {}\n\n",
                file.file_type,
                crate::export::format_file_size(file.size)
            ));
            key_files.push_str(&format!("{}\n\n", summary));
        }

        Ok(key_files)
    }

    /// Build dependencies section
    fn build_dependencies(&self, files: &[File]) -> Result<String> {
        let mut deps = String::from("## Dependencies\n\n");

        // Find and parse dependency files
        let cargo_toml = files.iter().find(|f| f.filename == "Cargo.toml");
        let package_json = files.iter().find(|f| f.filename == "package.json");
        let requirements_txt = files.iter().find(|f| f.filename == "requirements.txt");

        if let Some(cargo) = cargo_toml {
            deps.push_str("### Rust Dependencies (Cargo.toml)\n\n");
            if let Ok(Some(content)) = crate::db::operations::get_file_content(self.db.get_connection(), cargo.id) {
                if let Some(text) = content.text_content {
                    deps.push_str(&self.extract_rust_dependencies(&text));
                }
            }
            deps.push_str("\n");
        }

        if let Some(package) = package_json {
            deps.push_str("### JavaScript Dependencies (package.json)\n\n");
            if let Ok(Some(content)) = crate::db::operations::get_file_content(self.db.get_connection(), package.id) {
                if let Some(text) = content.text_content {
                    deps.push_str(&self.extract_js_dependencies(&text));
                }
            }
            deps.push_str("\n");
        }

        if let Some(requirements) = requirements_txt {
            deps.push_str("### Python Dependencies (requirements.txt)\n\n");
            if let Ok(Some(content)) = crate::db::operations::get_file_content(self.db.get_connection(), requirements.id) {
                if let Some(text) = content.text_content {
                    deps.push_str("```\n");
                    deps.push_str(&text.lines().take(30).collect::<Vec<_>>().join("\n"));
                    deps.push_str("\n```\n\n");
                }
            }
        }

        Ok(deps)
    }

    /// Build code patterns section
    fn build_code_patterns(&self, files: &[File]) -> Result<String> {
        let mut patterns = String::from("## Code Patterns\n\n");

        // Detect common patterns
        let file_types: HashMap<String, usize> = files
            .iter()
            .fold(HashMap::new(), |mut acc, f| {
                *acc.entry(f.file_type.clone()).or_insert(0) += 1;
                acc
            });

        patterns.push_str("**File Distribution:**\n\n");
        let mut sorted_types: Vec<_> = file_types.iter().collect();
        sorted_types.sort_by(|a, b| b.1.cmp(a.1));

        for (file_type, count) in sorted_types.iter().take(10) {
            patterns.push_str(&format!("- `.{}`: {} files\n", file_type, count));
        }

        patterns.push_str("\n");
        Ok(patterns)
    }

    /// Build current state section
    fn build_current_state(&self, files: &[File]) -> Result<String> {
        let conn = self.db.get_connection();
        let (total_files, indexed_files, total_size) = crate::db::operations::get_db_stats(conn)?;

        let embedding_count = crate::db::operations::count_embeddings(conn)?;
        let coverage = if total_files > 0 {
            (indexed_files as f64 / total_files as f64 * 100.0) as i64
        } else {
            0
        };

        let last_indexed = files
            .iter()
            .map(|f| &f.last_indexed)
            .max()
            .cloned()
            .unwrap_or_else(|| "Never".to_string());

        Ok(format!(
            "## Current State\n\n\
             - **Total Files**: {}\n\
             - **Indexed Files**: {}\n\
             - **Files with Embeddings**: {}\n\
             - **Coverage**: {}%\n\
             - **Total Size**: {}\n\
             - **Last Indexed**: {}\n\n\
             ---\n\n\
             *This context file was automatically generated by Cortex. Use it to give Claude full \
             understanding of your project structure, architecture, and codebase.*\n",
            total_files,
            indexed_files,
            embedding_count,
            coverage,
            crate::export::format_file_size(total_size),
            last_indexed
        ))
    }

    /// Calculate export statistics
    fn calculate_stats(&self, files: &[File]) -> Result<ExportStats> {
        let conn = self.db.get_connection();
        let total_files = files.len();
        let files_with_embeddings = crate::db::operations::count_embeddings(conn)? as usize;
        let total_size_bytes: i64 = files.iter().map(|f| f.size).sum();

        // Estimate chunk count (assuming ~500 tokens per chunk, ~4 chars per token)
        // Average: 2000 characters per chunk
        let total_chunks = if total_size_bytes > 0 {
            ((total_size_bytes as f64) / 2000.0).ceil() as usize
        } else {
            0
        };

        Ok(ExportStats {
            total_files,
            total_chunks,
            total_size_bytes,
            files_with_embeddings,
            prompts_generated: 0, // Will be updated by bundler
        })
    }

    // Helper methods for detection/analysis

    fn detect_project_name(&self, files: &[File]) -> String {
        // Try to extract from package.json or Cargo.toml
        files.iter()
            .find(|f| f.filename == "package.json" || f.filename == "Cargo.toml")
            .and_then(|_| Some("Project".to_string()))
            .unwrap_or_else(|| {
                // Use root directory name
                files.first()
                    .and_then(|f| {
                        Path::new(&f.root_path)
                            .file_name()
                            .and_then(|n| n.to_str())
                            .map(|s| s.to_string())
                    })
                    .unwrap_or_else(|| "Unknown Project".to_string())
            })
    }

    fn detect_project_type(&self, files: &[File]) -> String {
        if files.iter().any(|f| f.filename == "Cargo.toml") {
            if files.iter().any(|f| f.filename == "package.json") {
                return "Rust + SvelteKit Desktop App (Tauri)".to_string();
            }
            return "Rust Application".to_string();
        }

        if files.iter().any(|f| f.filename == "package.json") {
            return "JavaScript/TypeScript Application".to_string();
        }

        if files.iter().any(|f| f.filename == "requirements.txt") {
            return "Python Application".to_string();
        }

        "Unknown".to_string()
    }

    fn detect_frameworks(&self, files: &[File]) -> Vec<String> {
        let mut frameworks = Vec::new();

        if files.iter().any(|f| f.filename == "tauri.conf.json") {
            frameworks.push("Tauri".to_string());
        }

        if files.iter().any(|f| f.path.contains("svelte.config")) {
            frameworks.push("SvelteKit".to_string());
        }

        if files.iter().any(|f| f.path.contains("next.config")) {
            frameworks.push("Next.js".to_string());
        }

        if files.iter().any(|f| f.filename == "main.py" && f.path.contains("fastapi")) {
            frameworks.push("FastAPI".to_string());
        }

        frameworks
    }

    fn detect_entry_points(&self, files: &[File]) -> Vec<String> {
        let mut entry_points = Vec::new();

        for file in files {
            if file.filename == "main.rs" || file.filename == "main.py" || file.filename == "index.ts" {
                entry_points.push(file.path.clone());
            }
        }

        entry_points
    }

    fn detect_architecture_pattern(&self, files: &[File]) -> String {
        // Simple heuristic based on directory structure
        let has_src = files.iter().any(|f| f.path.contains("/src/"));
        let has_lib = files.iter().any(|f| f.path.contains("/lib/"));
        let has_components = files.iter().any(|f| f.path.contains("/components/"));
        let has_services = files.iter().any(|f| f.path.contains("/services/"));

        if has_src && has_lib && has_components {
            return "Component-Based Architecture".to_string();
        }

        if has_services {
            return "Service-Oriented Architecture".to_string();
        }

        "Standard Project Structure".to_string()
    }

    fn detect_layers(&self, files: &[File]) -> Vec<(String, usize)> {
        let mut layers: HashMap<String, usize> = HashMap::new();

        for file in files {
            if file.path.contains("/ui/") || file.path.contains("/components/") {
                *layers.entry("UI Layer".to_string()).or_insert(0) += 1;
            } else if file.path.contains("/api/") || file.path.contains("/routes/") {
                *layers.entry("API Layer".to_string()).or_insert(0) += 1;
            } else if file.path.contains("/services/") || file.path.contains("/lib/") {
                *layers.entry("Business Logic".to_string()).or_insert(0) += 1;
            } else if file.path.contains("/db/") || file.path.contains("/models/") {
                *layers.entry("Data Layer".to_string()).or_insert(0) += 1;
            }
        }

        layers.into_iter().collect()
    }

    fn analyze_directory_structure(&self, files: &[File]) -> String {
        // Simple directory listing (top-level only)
        let mut dirs: HashMap<String, usize> = HashMap::new();

        for file in files {
            if let Some(parent) = Path::new(&file.path).parent() {
                if let Some(dir_str) = parent.to_str() {
                    *dirs.entry(dir_str.to_string()).or_insert(0) += 1;
                }
            }
        }

        let mut sorted_dirs: Vec<_> = dirs.iter().collect();
        sorted_dirs.sort_by(|a, b| b.1.cmp(a.1));

        sorted_dirs.iter()
            .take(10)
            .map(|(dir, count)| format!("{}: {} files", dir, count))
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn build_directory_tree(&self, files: &[File]) -> String {
        // Simplified tree (just list directories)
        let mut dirs: std::collections::HashSet<String> = std::collections::HashSet::new();

        for file in files {
            if let Some(parent) = Path::new(&file.path).parent() {
                if let Some(dir_str) = parent.to_str() {
                    dirs.insert(dir_str.to_string());
                }
            }
        }

        let mut sorted_dirs: Vec<_> = dirs.into_iter().collect();
        sorted_dirs.sort();

        sorted_dirs.join("\n")
    }

    fn identify_important_files(&self, files: &[File]) -> Vec<File> {
        let mut important = Vec::new();

        // Priority files
        let priority_names = vec![
            "main.rs", "lib.rs", "main.py", "index.ts", "app.ts", "App.tsx",
            "Cargo.toml", "package.json", "README.md", "ARCHITECTURE.md"
        ];

        for file in files {
            if priority_names.contains(&file.filename.as_str()) {
                important.push(file.clone());
            }
        }

        // Add config files
        for file in files {
            if file.filename.ends_with(".config.js") || file.filename.ends_with(".config.ts") {
                important.push(file.clone());
            }
        }

        important
    }

    fn extract_rust_dependencies(&self, cargo_toml: &str) -> String {
        let mut deps = String::from("```toml\n");

        // Simple extraction (look for [dependencies] section)
        let mut in_deps = false;
        for line in cargo_toml.lines() {
            if line.trim() == "[dependencies]" {
                in_deps = true;
            } else if line.trim().starts_with('[') && in_deps {
                break;
            }

            if in_deps {
                deps.push_str(line);
                deps.push('\n');
            }
        }

        deps.push_str("```\n");
        deps
    }

    fn extract_js_dependencies(&self, package_json: &str) -> String {
        // Simple extraction (show first 20 lines)
        let mut deps = String::from("```json\n");
        deps.push_str(&package_json.lines().take(20).collect::<Vec<_>>().join("\n"));
        deps.push_str("\n```\n");
        deps
    }
}
